<jittershader name="default">
	<description>Default Slab </description>
	<param name="tex0" type="int" default="0" />
	<param name="modelViewProjectionMatrix" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="textureMatrix0" type="mat4" state="TEXTURE0_MATRIX" />
	<param name="position" type="vec3" state="POSITION" />
	<param name="texcoord" type="vec2" state="TEXCOORD" />
	<param name="frame" type="int" state="FRAME" />
	<param name="texDim" type="vec2" state="TEXDIM0" />

	<param name="grain_amount" type="float" default="0.5" />
	<param name="colored" type="int" default="1" />
	<param name="color_tint" type="float" default="0.6" />
	<param name="grain_size" type="float" default="3.0" />
	<param name="luma_amount" type="float" default="1.0" />

	<language name="glsl" version="1.5">
		<bind param="tex0" program="fp" />
		<bind param="modelViewProjectionMatrix" program="vp" />
		<bind param="textureMatrix0" program="vp" />
		<bind param="position" program="vp" />
		<bind param="texcoord" program="vp" />
		<bind param="frame" program="fp" />
		<bind param="texDim" program="fp" />

		<bind param="grain_amount" program="fp" />
		<bind param="colored" program="fp" />
		<bind param="color_tint" program="fp" />
		<bind param="grain_size" program="fp" />
		<bind param="luma_amount" program="fp" />

		<program name="vp" type="vertex"  >
<![CDATA[
#version 330 core

in vec3 position;
in vec2 texcoord;
out jit_PerVertex {
	vec2 texcoord;
	vec2 normUV;
} jit_out;
uniform mat4 modelViewProjectionMatrix;
uniform mat4 textureMatrix0;

void main(void) {
	gl_Position = modelViewProjectionMatrix*vec4(position, 1.);
	jit_out.texcoord = vec2(textureMatrix0*vec4(texcoord, 0., 1.));
	jit_out.normUV = vec2(texcoord.x, 1 - texcoord.y);
}
]]>
</program>

<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core

in jit_PerVertex {
	vec2 texcoord;
	vec2 normUV;
} jit_in;
layout (location = 0) out vec4 outColor;

uniform samplerJit0 tex0;
uniform int frame, colored;
uniform vec2 texDim;
uniform float grain_amount, color_tint, grain_size, luma_amount;

#define OCTAVES 6.
#define PI 3.14159265359
#define TWOPI 6.28318530718 

uint wang_hash(inout uint seed){

    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
 
float RandomFloat01(inout uint seed) { 
	return float(wang_hash(seed)) / 4294967296.0; 
}

vec4 RandomVec401(inout uint seed) { 
	return vec4( 	RandomFloat01(seed),
					RandomFloat01(seed),
					RandomFloat01(seed),
					RandomFloat01(seed)); 
}

//a random texture generator, but you can also use a pre-computed perturbation texture
vec4 rnm(in vec2 tc) 
{
	uint seed = uint(jit_in.texcoord.x*3882) + uint(jit_in.texcoord.y*2933) + uint(frame*119) + uint(992);
    return RandomVec401(seed)*2 - 1;
}

float fade(in float t) {
	return t*t*t*(t*(t*6.0-15.0)+10.0);
}

float pnoise3D(in vec3 p)
{

    vec3 pi = 0.00390625*floor(p);
    pi = vec3(pi.x+0.001953125, pi.y+0.001953125, pi.z+0.001953125);
    vec3 pf = fract(p);     // Fractional part for interpolation


    // Noise contributions from (x=0, y=0), z=0 and z=1
    float perm00 = rnm(pi.xy).a ;
    vec3 grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0;
    grad000 = vec3(grad000.x - 1.0, grad000.y - 1.0, grad000.z - 1.0);
    float n000 = dot(grad000, pf);
    vec3 grad001 = rnm(vec2(perm00, pi.z + 0.00390625)).rgb * 4.0;
    grad001 = vec3(grad001.x - 1.0, grad001.y - 1.0, grad001.z - 1.0);
    float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));

    // Noise contributions from (x=0, y=1), z=0 and z=1
    float perm01 = rnm(pi.xy + vec2(0.0, 0.00390625)).a ;
    vec3 grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0;
    grad010 = vec3(grad010.x - 1.0, grad010.y - 1.0, grad010.z - 1.0);
    float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));
    vec3 grad011 = rnm(vec2(perm01, pi.z + 0.00390625)).rgb * 4.0;
    grad011 = vec3(grad011.x - 1.0, grad011.y - 1.0, grad011.z - 1.0);
    float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));

    // Noise contributions from (x=1, y=0), z=0 and z=1
    float perm10 = rnm(pi.xy + vec2(0.00390625, 0.0)).a ;
    vec3  grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0;
    grad100 = vec3(grad100.x - 1.0, grad100.y - 1.0, grad100.z - 1.0);
    float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));
    vec3  grad101 = rnm(vec2(perm10, pi.z + 0.00390625)).rgb * 4.0;
    grad101 = vec3(grad101.x - 1.0, grad101.y - 1.0, grad101.z - 1.0);
    float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));

    // Noise contributions from (x=1, y=1), z=0 and z=1
    float perm11 = rnm(pi.xy + vec2(0.00390625, 0.00390625)).a ;
    vec3  grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0;
    grad110 = vec3(grad110.x - 1.0, grad110.y - 1.0, grad110.z - 1.0);
    float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));
    vec3  grad111 = rnm(vec2(perm11, pi.z + 0.00390625)).rgb * 4.0;
    grad111 = vec3(grad111.x - 1.0, grad111.y - 1.0, grad111.z - 1.0);
    float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));

    // Blend contributions along x
    vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));

    // Blend contributions along y
    vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));

    // Blend contributions along z
    float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));

    // We're done, return the final noise value.
    return n_xyz;
}



//2d coordinate orientation thing
vec2 coordRot(in vec2 tc, in float angle)
{
	float aspect = texDim.x/texDim.y;
	float sin_angle = sin(angle);
	float cos_angle = cos(angle);
	tc = tc*2 - 1;
	tc.x *= aspect;
	float rotX = (tc.x*cos_angle) - (tc.y*sin_angle);
	float rotY = (tc.y*cos_angle) + (tc.x*sin_angle);
	rotX = ((rotX/aspect)*0.5+0.5);
	rotY = rotY*0.5+0.5;
	return vec2(rotX,rotY);
}

void main(void) {

	uint seed = uint(jit_in.texcoord.x*42282) + uint(jit_in.texcoord.y*11433) + uint(frame*593) + uint(441);

	vec3 rotOffset = vec3(1.425,3.892,5.835); //rotation offset values	
	vec2 rotCoordsR = coordRot(jit_in.normUV, float(frame) + rotOffset.x);
	vec2 grain_scale = texDim / grain_size;
	vec3 noise = vec3(pnoise3D(vec3(rotCoordsR * grain_scale,0.0)));

	if (colored == 1)
	{
		vec2 rotCoordsG = coordRot(jit_in.normUV, float(frame) + rotOffset.y);
		vec2 rotCoordsB = coordRot(jit_in.normUV, float(frame) + rotOffset.z);
		noise.g = mix(noise.r,pnoise3D(vec3(rotCoordsG * grain_scale,1.0)),color_tint);
		noise.b = mix(noise.r,pnoise3D(vec3(rotCoordsB * grain_scale,2.0)),color_tint);
	}	

	vec3 col = texture(tex0, jit_in.texcoord).rgb;

	//noisiness response curve based on scene luminance
	vec3 lumcoeff = vec3(0.299,0.587,0.114);
	float luminance = mix(0.0,dot(col, vec3(0.299,0.587,0.114)),luma_amount);
	float lum = smoothstep(0.2,0.0,luminance);
	lum += luminance;

	noise = mix(noise,vec3(0.0),pow(lum,4.0));
	col = col+noise*grain_amount;
   
	outColor =  vec4(col,1.0);

}
]]>
</program>
</language>
</jittershader>
